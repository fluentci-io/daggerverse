import gen/types.{type Directory, type GeneratedCode, type Module}
import gen/module_id.{type ModuleID}
import gen/type_def_id.{type TypeDefID}
import gen/query_tree
import gen/base_client
import utils.{compute_query}
import gleam/list
import gleam/dict
import gleam/dynamic

/// Modules used by this module
///
pub fn dependencies(module: Module) -> List(Module) {
  let assert Ok(response) =
    compute_query(
      list.concat([
        module.query_tree,
        [query_tree.new("dependencies", dict.new())],
      ]),
    )
  response
}

/// The dependencies as configured by the module
///
pub fn dependency_config(module: Module) -> List(String) {
  let assert Ok(response) =
    compute_query(
      list.concat([
        module.query_tree,
        [query_tree.new("dependencyConfig", dict.new())],
      ]),
    )
  response
}

/// The doc string of the module, if any
///
pub fn description(module: Module) -> String {
  let assert Ok(response) =
    compute_query(
      list.concat([
        module.query_tree,
        [query_tree.new("description", dict.new())],
      ]),
    )
  response
}

/// The code generated by the SDK&#x27;s runtime
///
pub fn generated_code(module: Module) -> GeneratedCode {
  base_client.new(
    list.concat([
      module.query_tree,
      [query_tree.new("generatedCode", dict.new())],
    ]),
  )
}

/// The ID of the module
///
pub fn id(module: Module) -> ModuleID {
  let assert Ok(response) =
    compute_query(
      list.concat([module.query_tree, [query_tree.new("id", dict.new())]]),
    )
  response
}

/// Interfaces served by this module
///
pub fn interfaces(module: Module) -> List(TypeDef) {
  let assert Ok(response) =
    compute_query(
      list.concat([
        module.query_tree,
        [query_tree.new("interfaces", dict.new())],
      ]),
    )
  response
}

/// The name of the module
///
pub fn name(module: Module) -> String {
  let assert Ok(response) =
    compute_query(
      list.concat([module.query_tree, [query_tree.new("name", dict.new())]]),
    )
  response
}

/// Objects served by this module
///
pub fn objects(module: Module) -> List(TypeDef) {
  let assert Ok(response) =
    compute_query(
      list.concat([module.query_tree, [query_tree.new("objects", dict.new())]]),
    )
  response
}

/// The SDK used by this module. Either a name of a builtin SDK or a module ref pointing to the SDK&#x27;s implementation.
///
pub fn sdk(module: Module) -> String {
  let assert Ok(response) =
    compute_query(
      list.concat([module.query_tree, [query_tree.new("sdk", dict.new())]]),
    )
  response
}

/// Serve a module&#x27;s API in the current session.
///     Note: this can only be called once per session.
///     In the future, it could return a stream or service to remove the side effect.
///
pub fn serve(module: Module) -> Void {
  let assert Ok(response) =
    compute_query(
      list.concat([module.query_tree, [query_tree.new("serve", dict.new())]]),
    )
  response
}

/// The directory containing the module&#x27;s source code
///
pub fn source_directory(module: Module) -> Directory {
  base_client.new(
    list.concat([
      module.query_tree,
      [query_tree.new("sourceDirectory", dict.new())],
    ]),
  )
}

/// The module&#x27;s subpath within the source directory
///
pub fn source_directory_sub_path(module: Module) -> String {
  let assert Ok(response) =
    compute_query(
      list.concat([
        module.query_tree,
        [query_tree.new("sourceDirectorySubPath", dict.new())],
      ]),
    )
  response
}

/// This module plus the given Interface type and associated functions
///
pub fn with_interface(module: Module, iface: TypeDefID) -> Module {
  base_client.new(
    list.concat([
      module.query_tree,
      [
        query_tree.new(
          "withInterface",
          dict.new()
          |> dict.insert("iface", dynamic.from(iface)),
        ),
      ],
    ]),
  )
}

/// This module plus the given Object type and associated functions
///
pub fn with_object(module: Module, object: TypeDefID) -> Module {
  base_client.new(
    list.concat([
      module.query_tree,
      [
        query_tree.new(
          "withObject",
          dict.new()
          |> dict.insert("object", dynamic.from(object)),
        ),
      ],
    ]),
  )
}
